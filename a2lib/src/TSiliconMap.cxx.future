#include "TSiliconMap.h"

TSiliconMap::TSiliconMap(int NSiliconModules)
{
   new TGeoManager("TGeo", "Root geometry manager");

   nSil=NSiliconModules;
   for (int i=0; i<nSil; i++)
   {
      Layer.push_back(ReturnLayer(i));
      SilName.push_back( ReturnSilName( i));

      // Grab the module parameters from the GeoManager
      int n = (int) gGeoManager->GetTopVolume()->GetNodes()->GetEntries();
      TGeoNode* node = NULL;
      for( int i = 0; i < n; i++ )
      {
         node = gGeoManager->GetTopVolume()->GetNode( i );
         if( strncmp(node->GetName(),SilName.at(i),4) == 0 ) break;
         else node = NULL;
      }

      if( node )
      {
         double fXCenter = node->GetMatrix()->GetTranslation()[0];
         double fYCenter = node->GetMatrix()->GetTranslation()[1];
         double fZCenter = node->GetMatrix()->GetTranslation()[2];

         double  radius = TMath::Sqrt( fXCenter*fXCenter + fYCenter*fYCenter );
         double fCos = fXCenter/radius;
         double fSin = fYCenter/radius;

         HybridX.push_back(fXCenter);
         HybridY.push_back(fYCenter);
         HybridZ.push_back(fZCenter);

         HybridCos.push_back(fCos);
         HybridSin.push_back(fSin);

      }
   }
}


//______________________________________________________________________________
int TSiliconMap::ReturnLayer(int SilNum)
{
  if(nSil == 72){
  // Take the module number 0..71
  // return the detector layer
  
  if(SilNum < 10) return 0;
  else if(SilNum >= 10 && SilNum < 22) return 1;
  else if(SilNum >= 22 && SilNum < 36) return 2;
  else if(SilNum >= 36 && SilNum < 46) return 0;
  else if(SilNum >= 46 && SilNum < 58) return 1;
  else if(SilNum >= 58 && SilNum < 72) return 2;

  return -1;
  }
  if(nSil == 60) {

  // Take the module number 0..59
  // return the detector layer

  if(SilNum < 8) return 0;
  else if(SilNum >= 8  && SilNum < 18) return 1;
  else if(SilNum >= 18 && SilNum < 30) return 2;
  else if(SilNum >= 30 && SilNum < 38) return 0;
  else if(SilNum >= 38 && SilNum < 48) return 1;
  else if(SilNum >= 48 && SilNum < 60) return 2;

  return -1;
  }
}


//______________________________________________________________________________
int TSiliconMap::ReturnSilNum(const char* SilName)
{
  if (nSil == 60) {
  // Return the silicon module number 0..59
  // from the silname e.g. 4si5

  int n1 = atoi( &SilName[0] );
  int n2 = 0;
  if( SilName[3] == 'A' )
    n2 = 10;
  else if( SilName[3] == 'B' )
    n2 = 11;
  else
    n2 = atoi( &SilName[3] );
  
  int number = 0;
  
  // AD end
   if( n1 == 0 )
    number = n2 ;
  if( n1 == 1 )
    number = n2 + 8;
  if( n1 == 2 )
    number = n2 + 18;
  // e+ end
  if( n1 == 3 )
    number = n2 + 30;
  if( n1 == 4 )
    number = n2 + 38;
  if( n1 == 5 )
    number = n2 + 48;
  return number;

  }
  
  if(nSil == 72) {
  // Return the silicon module number 0..71
  // from the silname e.g. 4si5

  int n1 = atoi( &SilName[0] );
  int n2 = 0;
  if( SilName[3] == 'A' )
    n2 = 10;
  else if( SilName[3] == 'B' )
    n2 = 11;
  else if( SilName[3] == 'C' )
    n2 = 12;
  else if( SilName[3] == 'D' )
    n2 = 13;
  else
    n2 = atoi( &SilName[3] );
  
  int number = 0;
  
  // AD end
  if( n1 == 0 ) number = n2;	       
  if( n1 == 1 ) number = n2 + 10;      
  if( n1 == 2 ) number = n2 + 10 + 12;
  // e+ end
  if( n1 == 3 ) number = n2 + 10 + 12 + 14;
  if( n1 == 4 ) number = n2 + 10 + 12 + 14 + 10;
  if( n1 == 5 ) number = n2 + 10 + 12 + 14 + 10 + 12;
  return number;
  }
}


//______________________________________________________________________________
char * TSiliconMap::ReturnSilName(int SilNum)
{
  assert( SilNum >= 0 );
  assert( SilNum < nSil );
  
  if(nSil == 72){
  // Return the silname e.g. 4si5
  // from the silicon module number 0..71

  char * name = new char[5];
  
  // AD end
  if ( SilNum < 10 ) sprintf(name,"0si%1d",SilNum);
  if ( SilNum >= 10 && SilNum < 22 )
  {
      if(SilNum == 20) sprintf(name, "1siA" );
      else if ( SilNum == 21 ) sprintf(name, "1siB");
      else  sprintf(name,"1si%1d",SilNum - 10 );
  }
  if ( SilNum >= 22 && SilNum < 36 )
  {
      if( SilNum == 32 ) sprintf( name,"2siA" );
      else if( SilNum == 33 ) sprintf( name,"2siB" );
      else if( SilNum == 34 ) sprintf( name,"2siC" );
      else if( SilNum == 35 ) sprintf( name,"2siD" );
      else sprintf(name,"2si%d",SilNum - 10 - 12);
  }

  if ( SilNum >= 36 && SilNum < 46 ) sprintf(name,"3si%1d",SilNum - 10 - 12 - 14);
  if ( SilNum >= 46 && SilNum < 58 )
  {
      if (SilNum == 56) sprintf(name, "4siA");
      else if (SilNum == 57) sprintf(name, "4siB");
      else sprintf(name,"4si%1d",SilNum - 10 - 12 - 14 - 10);
  }
  if ( SilNum >= 58 && SilNum < 72 )
  {
      if( SilNum == 68 ) sprintf( name,"5siA" );
      else if( SilNum == 69 ) sprintf( name,"5siB" );
      else if( SilNum == 70 ) sprintf( name,"5siC" );
      else if( SilNum == 71 ) sprintf( name,"5siD" );
      else sprintf(name,"5si%1d",SilNum - 10 - 12 - 14 - 10 - 12);
  }
  return name;
}
  
  
  if(nSil ==60) {
    // Return the silname e.g. 4si5
    // from the silicon module number 0..59

    char * name = new char[5];
  // AD end
    if ( SilNum < 8 )
      {
        sprintf(name,"0si%1d",SilNum);
      }
    if ( SilNum >= 8 && SilNum < 18 )
      {
        sprintf(name,"1si%1d",SilNum - 8);
      }
    if ( SilNum >=18 && SilNum < 30 )
      {
        if( SilNum == 28 )
          sprintf( name,"2siA" );
        else if( SilNum == 29 )
          sprintf( name,"2siB" );

        else
          sprintf(name,"2si%d",SilNum - 18);
      }
      
    // e+ end
    if ( SilNum >= 30 && SilNum < 38 )
      {
        sprintf(name,"3si%1d",SilNum - 30);
      }
    if ( SilNum >= 38 && SilNum < 48 )
      {
        sprintf(name,"4si%1d",SilNum - 38);
      }
    if ( SilNum >= 48 && SilNum < 60 )
      {
        if( SilNum == 58)
          sprintf( name,"5siA" );
        else if( SilNum == 59 )
          sprintf( name,"5siB" );
        else
          sprintf(name,"5si%1d",SilNum - 48);
  
      }
  return name;
  }
}



//______________________________________________________________________________
double TSiliconMap::GetnPos(int silnum, double strip)
{
// given strip number [0,255] returns strip position (z coordinate in MRS)
// strips [0,127] are ASIC 1 which starts at 
// "ASIC1_start" (z coordinate in the local reference frame of the hybrid)
// strips [128,255] are ASIC 2 which starts at
// "ASIC2_start" (z coordinate in the local reference frame of the hybrid)
// values in mm, output in cm

  assert( strip >= 0  );
  assert( strip < 256 );

  double n_pitch = SilNPitch()*10.;
  double PCBmount = 302.25;
  double ASIC1_start = -188.338;
  double ASIC2_start = -72.938;

  double n = 0.;
  if( strip < 128. ) n = ASIC1_start - n_pitch*strip; // ASIC 1
  else n = ASIC2_start - n_pitch*(strip-128.);  // ASIC 2

  n+=PCBmount;
  if( silnum < nSil/2 ) n *= -1.;

  return n/10.;
}


//______________________________________________________________________________
double TSiliconMap::GetpPos(int silnum, double strip)
{
// given strip number [0,255] returns strip position (y coordinate in the 
// local reference frame of the hybrid)
// strips [0,127] are ASIC 3 which starts at 
// "ASIC3_start" (y coordinate in the local reference frame of the hybrid)
// strips [128,255] are ASIC 4 which starts at
// "ASIC4_start" (y coordinate in the local reference frame of the hybrid)
// values in mm, output in cm

  assert( strip >= 0  );
  assert( strip < 256 );

  double p_pitch = SilPPitch()*10.; // mm
  double ASIC3_start = 28.938;
  double ASIC4_start = -0.1135;

  double p = 0.;
  double s = (double)strip;
  if ( strip < 128 ) p = (ASIC3_start - p_pitch*s); // ASIC 3
  else p = (ASIC4_start - p_pitch*(s-128.)); // ASIC 4
  
  if( silnum < nSil/2 ) p *= -1.0;
  
  return p/10.; // return in cm
}

double GetX(int silnum, double pStrip, double nStrip)
{
   double fY=GetpPos( silnum,  pStrip);
   double fX=0.;
   return fX*HybridCos[silnum] - fY*HybridSin[silnum] + fHybridX[silnum];
}
double GetY(int silnum, double pStrip, double nStrip)
{
   double fY=GetpPos( silnum, pStrip);
   double fX=0.;
   return fX*HybridSin[silnum] - fY*HybridCos[silnum] + fHybridY[silnum];
}
double GetZ(int silnum, double pStrip, double nStrip);
{
   return GetnPos(silnum,nStrip);
}
