#include <map>
#include <string>

#include <TString.h>
#include <TH1D.h>
#include <TH2D.h>
#include <TProfile.h>
#include <TStyle.h>
#include <TDirectory.h>
#include <TFile.h>
#include <TCanvas.h>
#include <TPaletteAxis.h>

#include "SignalsType.hh"
#include "IntGetters.h"
#include "TPCconstants.hh"

#include "DeformHistoLim.h"

ALPHAg::padmap pads;
int  rowhot = 140,
  sechot = 7,
  rowcold = 290, 
  seccold = 24;

int RunNumber=0;
double Nevents=0;

bool saveas=true;
bool NevtNorm=false;

std::map<std::pair<int,int>,int> padmap;
char sca[2][2] = {{'A','D'},{'B','C'}};
std::map<int,std::pair<string,string>> robin;


void ReadMap()
{
  TString fname = TString::Format("%s/ana/pad.map",getenv("AGRELEASE"));
  cout<<fname<<endl;
  ifstream f(fname.Data());
  int s,r,m;
  while(1)
    {
      f>>s>>r>>m;
      if( !f.good() ) break;
      pair<int,int> p = std::make_pair(s,r);
      padmap[p]=m;
    }
  cout<<"Pad map size: "<<padmap.size()<<endl;
  f.close();
}

string GetPWB(int sec, int row)
{
  std::pair<int,int> p = std::make_pair(sec,row);
  int pwb = padmap[p];
  std::string out("PWB");
  if( pwb < 10 ) out+='0';    
  out+=std::to_string(pwb);
  return out;
}

string GetSCA(int sec, int row)
{
  int x = int(row/36)%2;
  int s=sec-1;
  if(s<0) s=31;
  int y=int(s/2)%2;
  string out("SCA");
  out+=sca[x][y];
  return out;
}


void phspectrum( TFile* fin )
{
  fin->cd();

  int hotpad = pads.index(sechot,rowhot),
    coldpad =  pads.index(seccold,rowcold);

  gDirectory->cd("paddeconv/pwbwf");
  TH2D* hPWbAmp = (TH2D*) gROOT->FindObject("hPwbAmp");

  TString hname = TString::Format("hamphotch%d_%d_%d",hotpad,sechot,rowhot);
  TString htitle = TString::Format("Hot Pad;p.h. [ADC]");
  TH1D* hchhotamp = new TH1D(hname,htitle,1000,0.,4200.);

  hname = TString::Format("hampcoldch%d_%d_%d",coldpad,seccold,rowcold);
  htitle = TString::Format("Cold Pad;p.h. [ADC]");
  TH1D* hchcoldamp = new TH1D(hname,htitle,1000,0.,4200.);

  for(int b=1; b<=hPWbAmp->GetNbinsY(); ++b)
    {
      int bin = hPWbAmp->GetBin(hotpad+1,b);
      double bc = hPWbAmp->GetBinContent(bin);
      hchhotamp->SetBinContent(b,bc);

      bin = hPWbAmp->GetBin(coldpad+1,b);
      bc = hPWbAmp->GetBinContent(bin);
      hchcoldamp->SetBinContent(b,bc);
    }

  int rb = 10;
  hchhotamp->Rebin(rb);
  hchcoldamp->Rebin(rb);

  double maxy = hchhotamp->GetBinContent(hchhotamp->GetMaximumBin())>hchcoldamp->GetBinContent(hchcoldamp->GetMaximumBin())?hchhotamp->GetBinContent(hchhotamp->GetMaximumBin()):hchcoldamp->GetBinContent(hchcoldamp->GetMaximumBin());
  maxy*=1.1;
  hchhotamp->GetYaxis()->SetRangeUser(0.,maxy);
  hchcoldamp->GetYaxis()->SetRangeUser(0.,maxy);

  // hchhotamp->GetXaxis()->SetRangeUser(0.,4200.);
  // hchcoldamp->GetXaxis()->SetRangeUser(0.,4200.);

  TString cname="PadPulseSpectrumR";
  cname += RunNumber;
  TCanvas* c1 = new TCanvas(cname,cname,1800,1600);
  c1->Divide(1,2);
  c1->cd(1);
  hchhotamp->Draw();
  c1->cd(2);
  hchcoldamp->Draw();
  if(saveas) c1->SaveAs(".pdf");
}

void phspectrum_tracks( TFile* fin )
{
  gStyle->SetOptStat("nem");

  int hotpad = pads.index(sechot,rowhot),
    coldpad =  pads.index(seccold,rowcold);

  fin->cd();
  gDirectory->cd("phspectrum");
  TH2D* hpwbphspect = (TH2D*) gDirectory->Get("hpwbphspect");

  TString hname = TString::Format("hphspecthotpad%d_%d_%d",hotpad,sechot,rowhot);
  TH1D* hhotphspect = hpwbphspect->ProjectionY(hname,hotpad+1,hotpad+1);
  hhotphspect->SetTitle("Hot Pad Spectrum for tracks;p.h. [ADC]");
  hhotphspect->Rebin(10);

  hname = TString::Format("hphspectcoldpad%d_%d_%d",coldpad,seccold,rowcold);
  TH1D* hcoldphspect = hpwbphspect->ProjectionY(hname,coldpad+1,coldpad+1);
  hcoldphspect->SetTitle("Cold Pad Spectrum for tracks;p.h. [ADC]");
  hcoldphspect->Rebin(10);

  double maxy = hhotphspect->GetBinContent(hhotphspect->GetMaximumBin())>hcoldphspect->GetBinContent(hcoldphspect->GetMaximumBin())?hhotphspect->GetBinContent(hhotphspect->GetMaximumBin()):hcoldphspect->GetBinContent(hcoldphspect->GetMaximumBin());
  maxy*=1.1;
  hhotphspect->GetYaxis()->SetRangeUser(0.,maxy);
  hcoldphspect->GetYaxis()->SetRangeUser(0.,maxy);

  TString cname="PadTracksPHSpectrumR";
  cname += RunNumber;
  TCanvas* c1 = new TCanvas(cname,cname,1800,1600);
  c1->Divide(1,2);
  c1->cd(1);
  hhotphspect->Draw();
  c1->cd(2);
  hcoldphspect->Draw();
  if(saveas) c1->SaveAs(".pdf");

  int bin = hhotphspect->FindBin(4096);
  cout<<"Entries hot pad: "<<hhotphspect->Integral(1,bin-1)<<endl;
  cout<<"Entries hot pad overflow: "<<hhotphspect->Integral(bin,bin+1)<<"\t"<<hhotphspect->GetBinContent(bin)<<endl;
  bin = hcoldphspect->FindBin(4096);
  cout<<"Entries cold pad: "<<hcoldphspect->Integral(1,bin-1)<<endl;
  cout<<"Entries cold pad overflow: "<<hcoldphspect->Integral(bin,bin+1)<<"\t"<<hcoldphspect->GetBinContent(bin)<<endl;

  bin = hhotphspect->FindBin(4096);
  cout<<"Integral hot pad: "<<hhotphspect->Integral(1,bin-1,"width")<<endl;
  cout<<"Integral hot pad overflow: "<<hhotphspect->Integral(bin,bin+1,"width")<<endl;
  bin = hcoldphspect->FindBin(4096);
  cout<<"Integral cold pad: "<<hcoldphspect->Integral(1,bin-1,"width")<<endl;
  cout<<"Integral cold pad overflow: "<<hcoldphspect->Integral(bin,bin+1,"width")<<endl;

  TH2D* hadcphspect = (TH2D*) gDirectory->Get("hadcphspect");
  int hotsecaw = sechot*8+3;
  hname = TString::Format("hphspecthotaw%d_%d",hotsecaw,sechot);
  TH1D* hhotsec = hadcphspect->ProjectionY(hname,hotsecaw+1,hotsecaw+1);
  hhotsec->SetTitle("AW in Hot Pad Sector Spectrum for tracks;p.h. [ADC]");
  hhotsec->Rebin(10);
  int coldsecaw = seccold*8+3;
  hname = TString::Format("hphspectcoldaw%d_%d",coldsecaw,seccold);
  TH1D* hcoldsec = hadcphspect->ProjectionY(hname,coldsecaw+1,coldsecaw+1);
  hcoldsec->SetTitle("AW in Cold Pad Sector Spectrum for tracks;p.h. [ADC]");
  hcoldsec->Rebin(10);

  maxy = hhotsec->GetBinContent(hhotsec->GetMaximumBin())>hcoldsec->GetBinContent(hcoldsec->GetMaximumBin())?hhotsec->GetBinContent(hhotsec->GetMaximumBin()):hcoldsec->GetBinContent(hcoldsec->GetMaximumBin());
  maxy*=1.1;
  hhotsec->GetYaxis()->SetRangeUser(0.,maxy);
  hcoldsec->GetYaxis()->SetRangeUser(0.,maxy);

  cname="AWTracksPHSpectrumR";
  cname += RunNumber;
  TCanvas* c2 = new TCanvas(cname,cname,1800,1600);
  c2->Divide(1,2);
  c2->cd(1);
  hhotsec->Draw();
  c2->cd(2);
  hcoldsec->Draw();
  if(saveas) c2->SaveAs(".pdf");

  bin = hhotsec->FindBin(16384);
  cout<<"Entries hot pad sec aw: "<<hhotsec->Integral(1,bin-1)<<endl;
  cout<<"Entries hot pad sec aw overflow: "<<hhotsec->Integral(bin,bin+1)<<"\t"<<hhotsec->GetBinContent(bin)<<endl;
  bin = hcoldsec->FindBin(16384);
  cout<<"Entries cold pad sec aw: "<<hcoldsec->Integral(1,bin-1)<<endl;
  cout<<"Entries cold pad sec aw overflow: "<<hcoldsec->Integral(bin,bin+1)<<"\t"<<hcoldsec->GetBinContent(bin)<<endl;
}

void multiphspectrum_tracks( TFile* fin )
{
  gStyle->SetOptStat("nem");

  int rowhot_1 = rowhot+1,
    sechot_1 = sechot+1,
    rowcold_1 = rowcold+1,
    seccold_1 = seccold+1;

  int padlist[] = {pads.index(sechot,rowhot),pads.index(sechot,rowhot_1), // hot region
		   pads.index(sechot_1,rowhot),pads.index(sechot_1,rowhot_1),
		   pads.index(sechot,rowcold),pads.index(sechot,rowcold_1), // hot sector, cold row
		   pads.index(sechot_1,rowcold),pads.index(sechot_1,rowcold_1),
		   pads.index(seccold,rowhot),pads.index(seccold,rowhot_1),   // cold sector, hot row
		   pads.index(seccold_1,rowhot),pads.index(seccold_1,rowhot_1),
		   pads.index(seccold,rowcold),pads.index(seccold,rowcold_1), // cold region
		   pads.index(seccold_1,rowcold),pads.index(seccold_1,rowcold_1)};
  string names[] = {"hot region - sec: "+std::to_string(sechot)+" row: "+std::to_string(rowhot),                   // 13
		    "hot region - sec: "+std::to_string(sechot)+" row: "+std::to_string(rowhot_1),                 // 14
		    "hot region - sec: "+std::to_string(sechot_1)+" row: "+std::to_string(rowhot),                 // 9
		    "hot region - sec: "+std::to_string(sechot_1)+" row: "+std::to_string(rowhot_1),// end         // 10
		    "hot sec: "+std::to_string(sechot)+" cold row: "+std::to_string(rowcold),                      // 15
		    "hot sec: "+std::to_string(sechot)+" cold row: "+std::to_string(rowcold_1),                    // 16
		    "hot sec: "+std::to_string(sechot_1)+" cold row: "+std::to_string(rowcold),                    // 11
		    "hot sec: "+std::to_string(sechot_1)+" cold row: "+std::to_string(rowcold_1), // end           // 12
		    "cold sec: "+std::to_string(seccold)+" hot row: "+std::to_string(rowhot),                      // 5
		    "cold sec: "+std::to_string(seccold)+" hot row: "+std::to_string(rowhot_1),                    // 6
		    "cold sec: "+std::to_string(seccold_1)+" hot row: "+std::to_string(rowhot),                    // 1  
		    "cold sec: "+std::to_string(seccold_1)+" hot row: "+std::to_string(rowhot_1), // end           // 2  
		    "cold region - sec: "+std::to_string(seccold)+" row: "+std::to_string(rowcold),                // 7
		    "cold region - sec: "+std::to_string(seccold)+" row: "+std::to_string(rowcold_1),              // 8
		    "cold region - sec: "+std::to_string(seccold_1)+" row: "+std::to_string(rowcold),              // 3
		    "cold region - sec: "+std::to_string(seccold_1)+" row: "+std::to_string(rowcold_1)}; // end    // 4
  //int order[] = {1,5,9,13,2,6,10,14,3,7,11,15,4,8,12,16};
  int order[] = {13,14,9,10,15,16,11,12,5,6,1,2,7,8,3,4};

  const int n = sizeof(padlist)/sizeof(int);
  //cout<<n<<"\t"<<sizeof(names)/sizeof(string)<<endl;
  fin->cd();
  gDirectory->cd("phspectrum");
  TH2D* hpwbphspect = (TH2D*) gDirectory->Get("hpwbphspect");
  double maxy=0.0;
  TH1D* h[n];
  for(int i=0; i<n; ++i)
    {
      TString hname = TString::Format("hphspect%d",padlist[i]);
      h[i] = hpwbphspect->ProjectionY(hname,padlist[i]+1,padlist[i]+1);
      TString htitle = "p.h. Spectrum "+names[i]+";p.h. [ADC]";
      h[i]->SetTitle(htitle);
      h[i]->Rebin(10);
      maxy=h[i]->GetBinContent(h[i]->GetMaximumBin())>maxy?h[i]->GetBinContent(h[i]->GetMaximumBin()):maxy;
    }
  maxy*=1.1;
  for(int i=0; i<n; ++i)
    h[i]->GetYaxis()->SetRangeUser(0.,maxy);
  
  TString cname="ManyPadTracksPHSpectrumR";
  cname += RunNumber;
  TCanvas* c1 = new TCanvas(cname,cname,2800,2600);
  c1->Divide(4,4);
  for(int i=0; i<n; ++i)
    {
      c1->cd(order[i]);
      //c1->cd(i+1);
      h[i]->Draw();
      int bin = h[i]->FindBin(4096);
      cout<<"Entries "<<names[i]<<" -> "<<h[i]->Integral(1,bin-1)<<", overflow: "<<h[i]->Integral(bin,bin+1)
	  <<"\tIntegral (excl. OFL): "<<h[i]->Integral(1,bin-1,"width")
	  <<"\tIntegral: "<<h[i]->Integral("width")<<endl;
    }
  if(saveas) c1->SaveAs(".pdf");

  cout<<"-------------------------------------------------------------------------------------------------"<<endl;
  TH1D* h4[4];
  TString h4name[] = {"hphspectHot","hphspectHotSecColdRow","hphspectColdSecHotRow","hphspectCold"};
  TString h4title[] = {"Hot Region;p.h. [ADC]","Hot Sector Cold Row;p.h. [ADC]","Cold Sector Hot Row;p.h. [ADC]","Cold Region;p.h. [ADC]"};
  for(int i=0; i<4; ++i)
    h4[i] = new TH1D(h4name[i],h4title[i],h[0]->GetNbinsX(),0.,4200.);
  for(int i=0; i<n; ++i)
    {
      int j = i/4;
      h4[j]->Add(h[i]);
    }
  double newmaxy=0.0;
  for(int i=0; i<4; ++i)
    newmaxy=h4[i]->GetBinContent(h4[i]->GetMaximumBin())>newmaxy?h4[i]->GetBinContent(h4[i]->GetMaximumBin()):newmaxy;
  newmaxy*=1.1;
  int neworder[] = {3,4,1,2};

  cname="SumPadTracksPHSpectrumR";
  cname += RunNumber;
  TCanvas* c2 = new TCanvas(cname,cname,2800,2600);
  c2->Divide(2,2);
  for(int i=0; i<4; ++i)
    {
      h4[i]->GetYaxis()->SetRangeUser(0.,newmaxy);
      c2->cd(neworder[i]);
      h4[i]->Draw();
      int bin = h4[i]->FindBin(4096);
      cout<<"Entries "<<h4[i]->GetName()<<" -> "<<h4[i]->Integral(1,bin-1)<<", overflow: "<<h4[i]->Integral(bin,bin+1)
	  <<"\tIntegral (excl. OFL): "<<h4[i]->Integral(1,bin-1,"width")
	  <<"\tIntegral: "<<h4[i]->Integral("width")<<endl;
    }
  if(saveas) c2->SaveAs(".pdf");
}

void GainCorrection(TH2D* hsca)
{
  cout<<"Gain Correction"<<endl;
  int minbin = hsca->GetMinimumBin();
  int maxbin = hsca->GetMaximumBin();
  cout<<"min bin: "<<minbin<<"\tmax bin: "<<maxbin<<endl;

  int minbinx,minbiny,maxbinx,maxbiny,dummy;
  hsca->GetBinXYZ(minbin,minbinx,minbiny,dummy);
  hsca->GetBinXYZ(maxbin,maxbinx,maxbiny,dummy);
  cout<<"min bin (x,y): "<<minbinx<<","<<minbiny<<"\tmax bin (x,y): "<<maxbinx<<","<<maxbiny<<endl;
  double min = hsca->GetBinContent(minbin);
  double max = hsca->GetBinContent(maxbin);
  cout<<"min: "<<min<<"\tmax: "<<max<<endl;

  TH2D* hsca_ratio = (TH2D*) hsca->Clone();
  hsca_ratio->SetTitle("Possible SCA Gain Assignment");
  
  std::string foutname=getenv("AGRELEASE");
  foutname+="/ana/sca_gain_correction_R";
  foutname+=std::to_string(RunNumber);
  foutname+=".dat";
  ofstream fout(foutname);
  for(int bx=1; bx<=hsca->GetNbinsX(); ++bx)
    for(int by=1; by<=hsca->GetNbinsY(); ++by)
      {
	double bc = hsca_ratio->GetBinContent(bx,by);
	//double sca_gain = round(bc/min);
	double sca_gain = bc/min;
	hsca_ratio->SetBinContent(bx,by,sca_gain);
	//	  hsca_ratio->SetBinContent(bx,by,(bc-min)/min);
	int bin = hsca_ratio->GetBin(bx,by);
	fout<<robin[bin].first<<"\t"<<robin[bin].second<<"\t"<<sca_gain<<endl;
      }
  cout<<"robin size: "<<robin.size()<<endl;
  fout.close();
  
  // cname = "AFTERamptextR";
  // cname += RunNumber;
  // TCanvas* c1 = new TCanvas(cname.Data(),cname.Data(),1800,1200);
  // hsca->Draw("coltext");
  // c1->SetGrid();
  // c1->SaveAs(".pdf");

  TString cname = "AFTERratioR";
  cname += RunNumber;
  TCanvas* c2 = new TCanvas(cname.Data(),cname.Data(),1900,1200);
  hsca_ratio->Draw("textcol");
  c2->SetGrid();
  c2->SaveAs(".pdf");
}


void OverFlowCalc(TH2D* hOF, TH2D* hocc)
{
  hOF->SetStats(kFALSE);
  cout<<hOF->GetName()<<" Entries: "<<hOF->GetEntries()<<endl;
  hOF->SetMinimum(min_ofl);
  hOF->SetMaximum(max_ofl);

  TH2D* hofl = new TH2D("hofl","Number of Overflow/Occupancy Pads;row;sec;N",576,0.,576.,32,0.,32.);
  hofl->SetStats(kFALSE);
  hofl->Divide(hOF,hocc);
  double min_olf_ratio=1.e-4;
  cout<<"---------------------------"<<endl;
  cout<<"----- dirty trick ---------"<<endl;
  int tmpbin=hofl->GetBin(326,12);
  hofl->SetBinContent(tmpbin,min_olf_ratio);
  tmpbin=hofl->GetBin(327,12);
  hofl->SetBinContent(tmpbin,min_olf_ratio);
  cout<<"---------------------------"<<endl;
  hofl->SetMinimum(min_olf_ratio);
  //  hofl->SetMaximum(0.25);


  TH2D* hscaoverflow = new TH2D("hscaoverflow","Overflow Frequency by AFTER;Along the axis;Along the Circle",16,0.,16.,16,0.,16.);
  hscaoverflow->SetStats(kFALSE);

  TH2D* hscaofl = new TH2D("hscaofl","Number of Overflow/Occupancy AFTER;row;sec;N",16,0.,16.,16,0.,16.);
  hscaofl->SetStats(kFALSE);

  for(int r = 0; r<576; ++r)
    {
      int sca_row = r/36;
      for(int s = 0; s<32; ++s)
  	{
  	  int sca_col = (s-1)/2;
  	  if( s == 0 ) sca_col = 15;
  	  int bin = hOF->GetBin(r+1,s+1);
  	  double amp = hOF->GetBinContent( bin );
  	  hscaoverflow->Fill(sca_row,sca_col,amp);

  	  double occ = hocc->GetBinContent( bin );
  	  if( occ > 0. )
  	    {
  	      double ratio = amp / occ;
  	      hscaofl->Fill(sca_row,sca_col,ratio);
  	    }
  	}
    }


  TString cname = "PadOverflowR";
  cname += RunNumber;
  if( NevtNorm ) hOF->Scale(1./Nevents);
  else cname+= "_NoNorm";
  TCanvas* c3 = new TCanvas(cname.Data(),cname.Data(),1800,1200);
  hOF->Draw("colz");
  c3->ToggleEventStatus();
  c3->Update();
  TPaletteAxis *pal3 = (TPaletteAxis*) hOF->GetListOfFunctions()->FindObject("palette");
  pal3->SetX1NDC(0.91);
  pal3->SetX2NDC(0.92);
  if(saveas) c3->SaveAs(".pdf");

  cname = "PadOverflowOverOccupancyR";
  cname += RunNumber;
  TCanvas* ca = new TCanvas(cname.Data(),cname.Data(),1800,1200);
  hofl->Draw("colz");
  ca->ToggleEventStatus();
  ca->Update();
  TPaletteAxis *pala = (TPaletteAxis*) hofl->GetListOfFunctions()->FindObject("palette");
  pala->SetX1NDC(0.91);
  pala->SetX2NDC(0.92);
  if(saveas) ca->SaveAs(".pdf");

 
  cname = "AFTEROverflowOverOccupancyR";
  cname += RunNumber;
  TCanvas* cb = new TCanvas(cname.Data(),cname.Data(),1800,1200);
  hscaofl->Draw("colz");
  cb->Update();
  TPaletteAxis *palb = (TPaletteAxis*) hscaofl->GetListOfFunctions()->FindObject("palette");
  palb->SetX1NDC(0.91);
  palb->SetX2NDC(0.92);
  if(saveas) cb->SaveAs(".pdf");

  cname = "AFTERoverflowR";
  cname += RunNumber;
  TCanvas* c5 = new TCanvas(cname.Data(),cname.Data(),1800,1200);
  hscaoverflow->Draw("colz");
  c5->Update();
  TPaletteAxis *pal5 = (TPaletteAxis*) hscaoverflow->GetListOfFunctions()->FindObject("palette");
  pal5->SetX1NDC(0.91);
  pal5->SetX2NDC(0.92);
  if(saveas) c5->SaveAs(".pdf");
}

void deformation(TFile* fin)
{
  fin->cd();

  gDirectory->cd("match_el");
  TH1D* hnm = (TH1D*) gROOT->FindObject("hNmatch");
  Nevents = (double) hnm->GetEntries();
  cout<<"Number of events for "<<RunNumber<<" is "<<Nevents<<endl; 

  gDirectory->cd("/");
  gDirectory->cd("paddeconv");
  
  TH2D* hpadocc = (TH2D*) gROOT->FindObject("hOccPad");
  hpadocc->SetStats(kFALSE);
  cout<<hpadocc->GetName()<<"   min: "<<hpadocc->GetMinimum()<<"   max: "<<hpadocc->GetMaximum()<<endl;
  hpadocc->SetMinimum(min_occ);
  hpadocc->SetMaximum(max_occ);
  
  gDirectory->cd("pwbwf");
  TH2D* hOF = (TH2D*) gROOT->FindObject("hPadOverflow");
  if( hOF )
    OverFlowCalc(hOF, hpadocc);
  else
    cout<<"no OF found"<<endl;
  
  TProfile* p = (TProfile*) gROOT->FindObject("hPwbAmp_prox");
  p->SetStats(kFALSE);
  p->SetMinimum(0.);
  p->SetMaximum(4096.);

  TH2D* hscamp = new TH2D("hscaamp","Average Maximum WF Amplitude by AFTER;Along the axis;Along the Circle",16,0.,16.,16,0.,16.);
  hscamp->SetStats(kFALSE);
 
  TH2D* hpadamp = new TH2D("hpadamp","Average Maximum WF Amplitude",576,0.,576.,32,0.,32.);
  hpadamp->SetStats(kFALSE);
 
  for(int b=1; b<=p->GetNbinsX(); ++b)
    {
      double amp = p->GetBinContent( b );
      int r,s;
      pads.get(b-1,s,r);
      int sca_row = r/36, sca_col = (s-1)/2;
      if( s == 0 ) sca_col = 15;

      int bin = hscamp->FindBin(sca_row,sca_col);
      robin[bin]=std::make_pair(GetPWB(s,r),GetSCA(s,r));

      hscamp->Fill(sca_row,sca_col,amp);
      hpadamp->Fill(r,s,amp);
    }
  hscamp->Scale(1./72.);
  GainCorrection( hscamp );

  hpadamp->SetMinimum(min_amp);
  hpadamp->SetMaximum(max_amp);


  TString cname = "PadOccupancyR";
  cname += RunNumber;
  if( NevtNorm ) hpadocc->Scale(1./Nevents);
  else cname+= "_NoNorm";
  TCanvas* c1 = new TCanvas(cname.Data(),cname.Data(),1800,1200);
  hpadocc->Draw("colz");
  c1->ToggleEventStatus();
  c1->Update();
  TPaletteAxis *pal1 = (TPaletteAxis*) hpadocc->GetListOfFunctions()->FindObject("palette");
  pal1->SetX1NDC(0.91);
  pal1->SetX2NDC(0.92);
  if(saveas) c1->SaveAs(".pdf");

  int mb,bx,by,bz;
  if( !NevtNorm )
    {
      cout<<hpadocc->GetName()<<"\t";
      mb = hpadocc->GetMaximumBin();
      hpadocc->GetBinXYZ(mb,bx,by,bz);
      cout<<"Max bin: "<<mb<<" row: "<<bx-1<<" sec: "<<by-1<<"\t"<<hpadocc->GetBinContent(mb)<<"\t";
      hpadocc->GetXaxis()->SetRange(25,576-25);
      mb = hpadocc->GetMinimumBin();
      hpadocc->GetBinXYZ(mb,bx,by,bz);
      cout<<"Min bin: "<<mb<<" row: "<<bx-1<<" sec: "<<by-1<<"\t"<<hpadocc->GetBinContent(mb)<<endl;
    }
  
  cname = "PadAverageAmpR";
  cname += RunNumber;
  TCanvas* c2 = new TCanvas(cname.Data(),cname.Data(),1800,1200);
  hpadamp->Draw("colz");
  c2->ToggleEventStatus();
  c2->Update();
  TPaletteAxis *pal2 = (TPaletteAxis*) hpadamp->GetListOfFunctions()->FindObject("palette");
  pal2->SetX1NDC(0.91);
  pal2->SetX2NDC(0.92);
  if(saveas) c2->SaveAs(".pdf");

  cout<<hpadamp->GetName()<<"\t";
  mb = hpadamp->GetMaximumBin();
  hpadamp->GetBinXYZ(mb,bx,by,bz);
  cout<<"Max bin: "<<mb<<" row: "<<bx-1<<" sec: "<<by-1<<"\t"<<hpadamp->GetBinContent(mb)<<"\t";
  hpadamp->GetXaxis()->SetRange(25,576-25);
  mb = hpadamp->GetMinimumBin();
  hpadamp->GetBinXYZ(mb,bx,by,bz);
  cout<<"Min bin: "<<mb<<" row: "<<bx-1<<" sec: "<<by-1<<"\t"<<hpadamp->GetBinContent(mb)<<endl;

  

  cname = "AFTERampR";
  cname += RunNumber;
  TCanvas* c4 = new TCanvas(cname.Data(),cname.Data(),1800,1200);
  //hscamp->Draw("colztext");
  hscamp->Draw("coltext");
  // c4->Update();
  // TPaletteAxis *pal4 = (TPaletteAxis*) hscamp->GetListOfFunctions()->FindObject("palette");
  // pal4->SetX1NDC(0.91);
  // pal4->SetX2NDC(0.92);
  if(saveas) c4->SaveAs(".pdf");

   
  cname = "PadAMPR";
  cname += RunNumber;
  TCanvas* c6 = new TCanvas(cname.Data(),cname.Data(),1800,1200);
  p->Draw();
  gPad->SetGridy();
  if(saveas) c6->SaveAs(".pdf");
}


void plotTPCdeformation()
{
  TFile* fin = (TFile*) gROOT->GetListOfFiles()->First();
  
  RunNumber = GetRunNumber( fin->GetName() );
  cout<<"Run Number: "<<RunNumber<<endl;

  SetHistoLimits( RunNumber );

  ReadMap();
  
  deformation(fin);
  phspectrum(fin);
  // phspectrum_tracks(fin);
  // multiphspectrum_tracks(fin);
}
